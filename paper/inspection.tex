Some semantic features allow a language to inspect some arbitrarily deep part of the stack, or compute a property of the whole stack before continuing.
%
Java's access control security features are an example of the first form of inspection, and garbage collection is an example of the second.
%
We will demonstrate both forms are simple first-order metafunctions that the AAM methodology will soundly interpret.
%
Access control can be modeled with continuation marks, so we demonstrate with the CM machine of \citeauthor{dvanhorn:Clements2004Tailrecursive}.

%%
Recursive metafunctions that inspect the stack can be thought of as out-of-band reduction relations that match rules in order until one fires, repeatedly until a return value is produced.
%
Interpreted via AAM, non-deterministic metafunction evaluation leads to a set of possible results.
%
The finite restriction on the state space carries over to metafunction inputs, so we can always detect infinite loops and bail out of that execution path.

Garbage collection, for example, needs to crawl the stack for live addresses.
%
The following function will produce the set of live addresses in the stack:

\begin{align*}
  \kontlive(\makont) &= \kontliveaux(\makont,\emptyset) \\[2pt]
  \kontliveaux(\epsilon,L) &= L \\
  \kontliveaux(\kcons{\mkframe}{\makont}, L) &= \kontliveaux(\makont, L\cup\touches(\mkframe)) \\
  \text{where } \touches(\appl{\mexpr,\menv}) &= \setbuild{\menv(\mvar)}{\mvar \in \fv(\mexpr)} \\
                \touches(\appr{\mval,\menv}) &= \setbuild{\menv(\mvar)}{\mvar \in \fv(\mval)}
\end{align*}

When interpreted via AAM, the continuation is indirected through $\mktab$ and leads to multiple results, and possibly loops through $\mktab$.
%
Thus this is more properly understood as
\begin{align*}
  \kontlive(\mktab,\makont) &= \terminal(\overline{\stepto},\kontliveaux(\mktab,\makont,\emptyset)) \\[2pt]
  \kontliveaux(\mktab,\epsilon,L) &\stepto_0 L \\
  \kontliveaux(\mktab,\kcons{\mkframe}{\mctx}, L) &\stepto_1 \kontliveaux(\mktab,\makont, L\cup\touches(\mkframe)) \text{ if } \makont \in \mktab(\mctx)
\end{align*}

where $\terminal$ is a metafunction that produces the set of irreducible terms of an input list of relations given a starting point:
\begin{align*}
  \terminal(\overline{R},s) &= \terminalaux(\set{s},\set{s},\emptyset) \\[2pt]
  \text{where } \terminalaux(S, \emptyset, T) &= T \\
   \terminalaux(S, F \uplus \set{s}, T) &= \terminalaux(S\cup I, F \cup (I \setminus S), T') \\
   & \text{where } (I',T') = \trystep(\overline{R}) \\
   \trystep(\epsilon) &= (\emptyset,T\cup\set{s}) \\
   \trystep(\stepto:\overline{R}) &= I\deceq\emptyset \to \trystep(\overline{R}), (I, T) \\
    & \text{where } I = \setbuild{s'}{s \stepto s'}
\end{align*}

This definition is a typical worklist implementation of a fixed-point computation.
%
It builds the set of terminal terms, $T$, by exploring the frontier (or worklist), $F$, and only adding terms to the frontier that have not been seen, as represented by $S$.
%
If a rule does not match a given term, the intermediate set, $I$ will be empty, and $\terminalaux$ will continue trying the following rules until it finds a match.
%

%
A garbage collecting semantics can choose to collect the heap with respect to each live set, or (soundly) collect with respect to their union.\footnote{The garbage collecting version of PDCFA~\citep{ianjohnson:DBLP:journals/jfp/JohnsonSEMH14} evaluates the second of these two strategies.}
%
On the one hand we could have tighter collections but more possible states, and on the other hand we can leave some precision behind in the hopes that the state space will be smaller.
%
\todo{DVH's CM machine}