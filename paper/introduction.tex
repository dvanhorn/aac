Good static analyses use a combination of abstraction techniques, economical data structures, and a lot of engineering~\citep{ianjohnson:CousotEtAl-TASE07,ianjohnson:DBLP:journals/ipl/YiCKK07}.
%
The cited exemplary works shine out from an innumerable amount of works that have attacked the problems with statically analyzing languages like C.
%
Dynamic languages do not yet have such gems.
%
The problem space is different, bigger, and full of new challenges.
%
The age-old technique of pushing abstract values around a graph to get an analysis shows its age -- old.
%
The first problem we must solve is, ``what graph?'' as control-flow is now part of the problem domain.
%
Second, features like stack inspection and first-class continuations are not easily shoe-horned into a CFG representation of a program's behavior.
%
We need a new approach before heavily investing in engineering effort.

%
Dynamic languages are sometimes referred to as ``interpreted languages'' by non-PL experts.
%
An expert would say the reality is that languages' semantics are not married to their implementation strategy; C can be interpreted, for example, but is known as a ``compiled language.''
%
Choosing an intellectual high-ground to dismiss popular terminology is socially and intellectually damaging.
%
The expert's ``reality'' is intangible platonism, when the honest real-world reality is that many, if not all, ``interpreted languages'' are implemented wholly or in part with interpreters.
%
Interpreters may be the key to correctly analyzing dynamic languages.
%

%
Luckily, there is an alternative to the old CFG approach to analysis construction that is based instead on abstract machines, which are one step away from interpreters (they are interderivable in several instances~\citep{ianjohnson:DBLP:conf/icfp/Danvy08}).
%
This alternative is called Abstracting Abstract Machines (AAM)~\citep{dvanhorn:VanHorn2012Systematic}, a powerfully simple idea that is generally applicable to even the most dynamic of languages, \eg{}, JavaScript~\citep{ianjohnson:DBLP:journals/corr/KashyapDKWGSWH14}.
%
A downside is that all effective instantiations of AAM are finite state approximations.
%
When precision is your only weapon against dynamism, this is unacceptable.
%
Finite state techniques cannot precisely predict where a method or function call will return.
%
This opens a flood gate to imprecision flowing everywhere through analyses' predictions.
%

%
We extend the AAM technique to computably handle infinite state state spaces by adapting pushdown abstraction methods to abstract machines.
%
The unbounded stack of pushdown systems is the mechanism to precisely match calls and returns.
%
We appeal to operational intuitions rather than automata theory to justify the approach.
%
The intention is that even novices with some experience implementing interpreters will be able to design analyses for their languages.
%
With simple but powerful tools in a large audience's toolbelt, we hope this work will help the community work towards technical feats like Astr\'ee~\citep{ianjohnson:CousotEtAl-TASE07}.
%
The large problem domain of analyzing dynamic languages needs an army to tackle it, and we believe that AAM can feed that army.