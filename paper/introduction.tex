Good static analyses use a combination of abstraction techniques, economical data structures, and a lot of engineering~\citep{ianjohnson:CousotEtAl-TASE07,ianjohnson:DBLP:journals/ipl/YiCKK07}.
%
The cited exemplary works shine out from an innumerable amount of works that have attacked the problems with statically analyzing languages like C.
%
Dynamic languages do not yet have such gems.
%
The problem space is different, bigger, and full of new challenges.
%
The age-old technique of pushing abstract values around a graph to get an analysis shows its age -- old.
%
The first problem we must solve is, ``what graph?'' as control-flow is now part of the problem domain.
%
Second, features like stack inspection and first-class continuations are not easily shoe-horned into a CFG representation of a program's behavior.
%
We need a new approach before heavily investing in engineering effort.

%
Dynamic languages are sometimes referred to as ``interpreted languages'' by non-PL experts.
%
Rather than scoff at a mistaken notion, we can learn from our constituents; perhaps they use this terminology because some dynamic features are either too difficult to compile ahead of time, or the runtime support resembles the interpreter pattern.
%
Either way, interpreters, not graphs, may be the key to correctly analyzing dynamic languages.
%

%
Luckily, there is an alternative to the old CFG approach to analysis construction that is based instead on abstract machines, which are one step away from interpreters (they are interderivable in several instances~\citep{ianjohnson:DBLP:conf/icfp/Danvy08}).
%
This alternative is called Abstracting Abstract Machines (AAM), a powerfully simple idea that is generally applicable to even the most dynamic of languages, \eg{}, JavaScript~\citep{ianjohnson:DBLP:journals/corr/KashyapDKWGSWH14}.
%
In the original work~\citep{dvanhorn:VanHorn2010Abstracting}, AAM showed that $k$-CFA is a specific instance of the framework, albeit all effective instantiations of AAM are finite state approximations.
%
When precision is your only weapon against dynamism, this is unacceptable.
%
Finite state techniques cannot precisely match the call and return points of method and function applications.
%
This opens a flood gate to imprecision flowing everywhere through analyses' predictions.
%

%
We extend the AAM technique to computably handle infinite state state spaces by adapting pushdown abstraction methods to abstract machines.
%
The unbounded stack of pushdown systems is the mechanism to precisely match calls and returns.
%
We appeal to operational intuitions rather than automata theory to justify the approach.
%
The intention is that even novices with some experience implementing interpreters will be able to design analyses for their languages.
%
With simple but powerful tools in a large audience's toolbelt, we hope our foundational work will help the community work towards gems like Astr\'ee~\citep{ianjohnson:CousotEtAl-TASE07}.
%
The large problem domain of analyzing dynamic languages needs an army to tackle it.
%
We believe that AAM can feed that army.