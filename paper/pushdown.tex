We can exactly represent the stack in the $\CESKstart$ machine with a modified allocation scheme for stacks.
%
The key idea is that if the address is ``precise enough,'' then every path that leads to the allocation will proceed exactly the same way until the address is dereferenced.
%

%
What constitutes ``precise enough?'' 
%
For the $\CESKstart$ machine, every function evaluates the same way, regardless of the stack.
%
We should then represent the stack addresses as the state that allocates it, without the rest of the stack.
%
We store stack addresses in a different table because execution is disregards the rest of the stack.
%
We will call this table $\mktab$, because it looks like a stack.
%

%
By not storing the continuations in the value store, we separate ``relevant'' components from ``irrelevant'' components.
%
We split the stack store from the value store and use only the value store in stack addresses.
%
The resulting state space is updated here:
  \begin{align*}
    \sa{State} &= \sa{CEK} \times \Store \times \Time \times \KStore \\
    \sa{Storeable} &= \wp(\Value \times \sa{Env}) \\
    \mkont \in \Kont &::= \epsilon \alt \kcons{\mkframe}{\mctx} \\
    \mctx \in \Context &::=  \tpl{\mexpr,\maenv,\mstore,\mtime} \\
    \mktab \in \KStore &= \Context \finto \wp(\Kont) \\
  \end{align*}
%
Stack addresses generally describe the relevant context that lead to their allocation, so we will refer to them henceforth as \emph{contexts}.

The semantics is modified slightly in \autoref{fig:ceskkstart-semantics} to use $\mktab$ instead of $\mstore$ for continuation allocation and lookup.
%
Since continuation addresses are drawn from a finite space, but still are precise enough to capture the unbounded behavior of the pushdown system, the machine will always terminate.
%
The computed $\stepto$ relation thus represents the full description of a pushdown system of reachable states.
%%
\begin{theorem}[Correctness]
  \todo{Ian}
\end{theorem}

%%
There are three optimizations that may be employed to accelerate the fixed-point computation.
\begin{enumerate}
\item{Observe that $\mktab$ can be made global with no loss in precision; it will not need to be stored in the frontier or set of seen states.}
\item{Continuations can be ``chunked'' more coarsely at function boundaries instead of at each frame in order to minimize table lookups.}
\item{Since evaluation is the same regardless of the stack, we can memoize results to short-circuit to the answer.}
\end{enumerate}
%
This last optimization will be covered in more detail in \autoref{sec:memo}

\begin{figure}
  \centering
  $\mastate,\mstore,\mtime,\mktab \stepto \mastate',\mstore',\tick(\mastate,\mstore,\mtime),\mktab'$ \quad $\maddr = \alloc(\mastate,\mstore,\mtime)$ \\
  \begin{tabular}{r|l}
    \hline\vspace{-3mm}\\
    $\tpl{\svar\mvar, \maenv, \makont}$
    &
    $\tpl{\mval, \maenv',\makont}$ if $(\mval,\menv') \in \mstore(\maenv(\mvar))$
    \\
% Application
    $\tpl{\sapp{\mexpri0}{\mexpri1},\maenv,\makont}$
    &
    $\tpl{\mexpri0,\maenv,\kcons{\appl{\mexpri1,\maenv}}{\mctx}}$ \\
    where & $\mctx = \tpl{\sapp{\mexpri}{\mexpri1},\maenv,\mstore,\mtime}$ \\
          & $\mktab' = \joinm{\mktab}{\mctx}{\makont}$
    \\
% Arg eval
    $\tpl{\mval,\maenv, \kcons{\appl{\mexpr,\maenv'}}{\mctx}}$
    &
    $\tpl{\mexpr,\maenv',\kcons{\appr{\mval,\maenv}}{\mctx}}$
    \\
% Function call
    $\tpl{\mval,\maenv,\kcons{\appr{\slam{\mvar}{\mexpr},\maenv'}}{\mctx}}$
    &
    $\tpl{\mexpr,\maenv'',\makont}$ if $\makont \in \mktab(\mctx)$ \\
    where & $\maenv'' = \maenv'[\mvar\mapsto\maddr]$ \\
          & $\mstore' = \joinm{\mstore}{\maddr}{(\mval,\maenv)}$
  \end{tabular} \\
  Where $\mstore' = \mstore$ and $\mktab' = \mktab$ unless otherwise stated.
  \caption{$\CESKKstart$ semantics}
  \label{fig:ceskkstart-semantics}
\end{figure}

\subsection{A more economical representation}

Flow analyses commonly split control-flow graphs at function call boundaries to enable the combination of intra- and inter-procedural analyses.
%
In an abstract machines, this split looks like installing a continuation prompt at function calls.
%
We borrow a representation from literature on delimited continuations to split the continuation into two components: the continuation and meta-continuation.
%
Our delimiters are special since each continuation ``chunk'' until the next prompt will be of bounded length.
%
The bound is roughly the deepest nesting depth of an expression in functions' bodies.
%
Instead of ``continuation'' and ``meta-continuation'' then, we will use terminology from CFA2 and call the top chunk a ``local continuation,'' and the rest the ``continuation.''
%
%

\begin{figure}
  \centering
  \begin{align*}
    \mstate \in \sa{CEIK} &= \tpl{\mexpr,\menv,\mlkont,\mkont} \\
    \mlkont \in \LKont &= \Frame^* \\
    \makont \in \Kont &= \Context + \set{\Halt}
  \end{align*}
  \caption{$\CESIKKstart$ semantic spaces}
  \label{fig:pushdown-spaces}
\end{figure}

The resulting shuffling of the semantics to accommodate this new representation is in \autoref{fig:cesikkstart-semantics}.
%
The extension to $\mktab$ happens in a different rule -- function entry -- so the shape of the context changes to hold the function, argument, store and time.
%
We have a choice of whether to introduce an administrative step to dereference $\mktab$ once $\mlkont$ is empty, or to use a helper metafunction to describe a ``pop'' of both $\mlkont$ and $\mkont$.
%
Suppose we choose the second because the resulting semantics has a 1-to-1 correspondence with the previous semantics.
%
A first try might land us here:
\begin{align*}
  \pop(\kcons{\mkframe}{\mlkont},\makont,\mktab) &= \set{(\mkframe,\mlkont,\makont)} \\
  \pop(\epsilon,\mctx,\mktab) &= \setbuild{(\mkframe,\mlkont,\makont)}{(\kcons{\mkframe}{\mlkont}, \makont) \in \mktab(\mctx)}
\end{align*}
However, tail calls make the dereferenced $\mctx$ lead to $(\epsilon,\mctx')$.
%
Because abstraction makes the store grow monotonically in a finite space, it's possible that $\mctx' = \mctx$ and a naive recursive definition of $\pop$ will diverge chasing these contexts.
%
Now $\pop$ must save all the contexts it dereferences in order to guard against divergence.
%
So $\pop(\mlkont,\makont,\mktab) = \popaux(\mlkont,\makont,\mktab,\emptyset)$ where
\begin{align*}
  \popaux(\epsilon,\epsilon,\mktab,G) &= \emptyset \\
  \popaux(\kcons{\mkframe}{\mlkont},\makont,\mktab,G) &= \set{(\mkframe,\mlkont,\makont)} \\
  \popaux(\epsilon,\mctx,\mktab,G) &= \setbuild{(\mkframe,\mlkont,\makont)}{(\kcons{\mkframe}{\mlkont}, \makont) \in \mktab(\mctx)} \\
  &\cup \bigcup\limits_{\mctx' \in G'}\popaux(\epsilon,\mctx',\mktab,G\cup G') \\
  \text{where } G' &= \setbuild{\mctx'}{(\epsilon,\mctx') \in \mktab(\mctx)} \setminus G
\end{align*}

In practice, one would not expect $G$ to grow very large.
%
Had we chosen the first strategy, the issue of divergence is delegated to the machinery from the fixed-point computation.\footnote{CFA2 employs the first strategy and calls it ``transitive summaries.''}
%
However, when adding the administrative state, the ``seen'' check requires searching a far larger set than we would expect $G$ to be.

\begin{figure}
  \centering
  $\mastate,\mstore,\mtime,\mktab \stepto \mastate',\mstore',\tick(\mastate,\mstore,\mtime),\mktab'$ \quad $\maddr = \alloc(\mstate,\mstore,\mtime)$ \\
  \begin{tabular}{r|l}
    \hline\vspace{-3mm}\\
    $\tpl{\svar\mvar, \maenv, \mlkont, \makont}$
    &
    $\tpl{\mval, \maenv',\mlkont,\makont}$ if $(\mval,\menv') \in \mstore(\maenv(\mvar))$
    \\
% Application
    $\tpl{\sapp{\mexpri0}{\mexpri1},\maenv,\mlkont,\makont}$
    &
    $\tpl{\mexpri0,\maenv,\kcons{\appl{\mexpri1,\maenv}}{\mlkont},\makont}$
    \\
% Arg eval
    $\tpl{\mval,\maenv, \mlkont,\makont}$
    &
    $\tpl{\mexpr,\maenv',\kcons{\appr{\mval,\maenv}}{\mlkont'},\makont'}$ \\
    &
    if $\appl{\mexpr,\maenv'}, \mlkont',\makont' \in \pop(\mlkont,\makont,\mktab)$ \\
% Function call
    $\tpl{\mval,\maenv, \mlkont,\makont}$
    &
    $\tpl{\mexpr,\maenv'[\mvar\mapsto\maddr],\epsilon,\mctx}$ \\
    & if $\appr{\slam{\mvar}{\mexpr},\maenv'}, \mlkont', \makont' \in \pop(\mlkont,\makont,\mktab)$ \\
    where & $\mstore' = \joinm{\mstore}{\maddr}{(\mval,\maenv)}$ \\
    & $\mctx = (\mval,\maenv,\slam{\mvar}{\mexpr},\maenv',\mstore,\mtime)$ \\
    & $\mktab' = \joinm{\mktab}{\mctx}{(\mlkont,\makont)}$
  \end{tabular} \\
  Where $\mstore' = \mstore$ and $\mktab' = \mktab$ unless otherwise stated.
  \caption{$\CESIKKstart$ semantics}
  \label{fig:cesikkstart-semantics}
\end{figure}

\begin{align*}
  {\mathcal F}(S,R,F,\mktab) &= (S \cup F, R \cup R', F'\setminus S, \mktab') \\
  I &= \bigcup\limits_{s=(\mstate,\mstore,\mtime) \in F}{\setbuild{(\tpl{s,s'}, \mktab')}{s,\mktab \stepto s',\mktab'}} \\
  R' &= \pi_0 I \\
  F' &= \pi_1 R' \\
  \mktab' &= \bigsqcup\pi_1 I
\end{align*}
For a program $\mexpr$, we will say $(\emptyset,\emptyset,\set{\tpl{\mexpr,\bot,\epsilon,\Halt}},\bot)$ is the bottom element of ${\mathcal F}$'s domain.
%
The ``analysis'' then is then the pair of the $R$ and $\mktab$ components of $\lfp({\mathcal F})$.

\begin{theorem}[Correctness]
  \todo{Ian}
\end{theorem}