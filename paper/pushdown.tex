We can exactly represent the stack in the $\CESKstart$ machine with a modified allocation scheme for stacks.
%
The key idea is that if the address is ``precise enough,'' then every path that leads to the allocation will proceed exactly the same way until the address is dereferenced.
%

%
What constitutes ``precise enough?'' 
%
For the $\CESKstart$ machine, every function evaluates the same way, regardless of the stack.
%
We should then represent the stack addresses as the state that allocates it, without the rest of the stack.
%
We store stack addresses in a different table because execution is disregards the rest of the stack.
%
We will call this table $\mktab$, because it looks like a stack.
%

%
By not storing the continuations in the value store, we separate ``relevant'' components from ``irrelevant'' components.
%
We split the stack store from the value store and use only the value store in stack addresses.
%
Stack addresses generally describe the relevant context that lead to their allocation, so we will refer to them henceforth as \emph{contexts}.
%
The resulting state space is updated here:
  \begin{align*}
    \sa{State} &= \sa{CEK} \times \Store \times \Time \times \KStore \\
    \maval \in \sa{Storeable} &= \wp(\Value \times \sa{Env}) \\
    \mkont \in \Kont &::= \epsilon \alt \kcons{\mkframe}{\mctx} \\
    \mctx \in \Context &::=  \tpl{\mexpr,\maenv,\mstore,\mtime} \\
    \mktab \in \KStore &= \Context \finto \wp(\Kont) \\
  \end{align*}

The semantics is modified slightly in \autoref{fig:ceskkstart-semantics} to use $\mktab$ instead of $\mstore$ for continuation allocation and lookup.
%
Given finite allocation, contexts are drawn from a finite space, but are still precise enough to describe an unbounded stack.
%
The computed $\stepto$ relation thus represents the full description of a pushdown system of reachable states (and the set of paths).
%
Of course this semantics does not always define a pushdown system since $\alloc$ can have an unbounded codomain.
%
The correctness claim is therefore a correspondence between the same machine but with an unbounded stack, no $\mktab$, and $\alloc, \tick$ functions that behave the same disregarding the different representations (a reasonable assumption).

\begin{figure}
  \centering
  $\mastate,\mstore,\mtime,\mktab \stepto \mastate',\mstore',\tick(\mastate,\mstore,\mtime),\mktab'$ \quad $\maddr = \alloc(\mastate,\mstore,\mtime)$ \\
  \begin{tabular}{r|l}
    \hline\vspace{-3mm}\\
    $\tpl{\svar\mvar, \maenv, \makont}$
    &
    $\tpl{\mval, \maenv',\makont}$ if $(\mval,\menv') \in \mstore(\maenv(\mvar))$
    \\
% Application
    $\tpl{\sapp{\mexpri0}{\mexpri1},\maenv,\makont}$
    &
    $\tpl{\mexpri0,\maenv,\kcons{\appl{\mexpri1,\maenv}}{\mctx}}$ \\
    where & $\mctx = \tpl{\sapp{\mexpri}{\mexpri1},\maenv,\mstore,\mtime}$ \\
          & $\mktab' = \joinm{\mktab}{\mctx}{\makont}$
    \\
% Arg eval
    $\tpl{\mval,\maenv, \kcons{\appl{\mexpr,\maenv'}}{\mctx}}$
    &
    $\tpl{\mexpr,\maenv',\kcons{\appr{\mval,\maenv}}{\mctx}}$
    \\
% Function call
    $\tpl{\mval,\maenv,\kcons{\appr{\slam{\mvar}{\mexpr},\maenv'}}{\mctx}}$
    &
    $\tpl{\mexpr,\maenv'',\makont}$ if $\makont \in \mktab(\mctx)$ \\
    where & $\maenv'' = \maenv'[\mvar\mapsto\maddr]$ \\
          & $\mstore' = \joinm{\mstore}{\maddr}{(\mval,\maenv)}$
  \end{tabular} \\
  Where $\mstore' = \mstore$ and $\mktab' = \mktab$ unless otherwise stated.
  \caption{$\CESKKstart$ semantics}
  \label{fig:ceskkstart-semantics}
\end{figure}

\subsection{Correctness}

The high level argument for correctness exploits properties of both machines.
%
Where the stack is unbounded (call this $\CESKt$), if every state in a trace shares a common tail in their continuations, that tail is \emph{irrelevant}.
%
This means the tail can be replaced with anything and still produce a valid trace.
%
We call this property more generally, ``context irrelevance.''
%
The $\CESKKstart$ machine maintains an invariant on $\mktab$ that says that $\makont \in \mktab(\mctx)$ represents a trace in $\CESKt$ that starts at the base of $\makont$ and reaches $\mctx$ with $\makont$ on top.
%
We can use this invariant and context irrelevance to translate steps in the $\CESKKstart$ machine into steps in $\CESKt$.
%
The other way around, we use a proposition that a full stack is represented by $\mktab$ via unrolling and follow a simple simulation argument.

The common tail proposition we will call $\hastail$ and the replacement function we will call $\replacetail$; they both have obvious inductive and recursive definitions respectively.
%
The invariant is stated with respect to the entire program, $\mexpr_\mathit{pgm}$:
\begin{mathpar}
  \inferrule{ }{\invmktab(\bot)} \quad
  \inferrule{\invmktab(\mktab) \\
      \forall \makont_c \in K. \startstate(\makont_c) \stepto_\CESKt^* \tpl{\mexpr_c,\maenv_c,\append{\mkont_c}{\epsilon}},\mstore_c,\mtime_c}
            {\invmktab(\mktab[\tpl{\mexpr_c,\maenv_c,\mstore_c,\mtime_c} \mapsto K])} \\

  \inferrule{
    % invariant for current state
    \startstate(\makont) \stepto_\CESKt^* \tpl{\mexpr,\maenv,\append{\makont}{\epsilon}},\mstore,\mtime \\
    % invariant for all entries
    \invmktab(\mktab)}
    {\inv(\tpl{\mexpr,\maenv,\makont},\mstore,\mtime,\mktab)}
  \end{mathpar}
where
\begin{align*}
 \startstate(\epsilon) &= \tpl{\mexpr_\mathit{pgm},\bot,\epsilon},\bot,\mtime_0 \\
                \startstate(\kcons{\mkframe}{\tpl{\mexpr_c,\maenv_c,\mstore_c,\mtime_c}}) &=
                \tpl{\mexpr_c,\maenv_c,\epsilon},\mstore_c,\mtime_c
\end{align*}
We use $\append{\cdot}{\epsilon}$ to treat $\mctx$ like $\epsilon$ and construct a continuation in $\Kont$ rather than $\sa{Kont}$.
%%
\begin{lemma}[Context irrelevance]\label{lem:irrelevance}
  For all traces $\mtrace \in \CESKt^*$ and continuations $\mkont$ such that $\hastail(\mtrace,\mkont)$, for any $\mkont'$, $\replacetail(\mtrace,\mkont,\mkont')$ is a valid trace.
\end{lemma}
\begin{proof}
  Simple induction on $\mtrace$ and cases on $\stepto_{\CESKt}$.
\end{proof}
\begin{lemma}[$\CESKKstart$ Invariant]\label{lem:invariant}
  For all $\mstate,\mstate' \in \sa{State}$, if $\inv(\mstate)$ and $\mstate \stepto \mstate'$, then $\inv(\mstate')$
\end{lemma}
\begin{proof}
  Routine case analysis.
\end{proof}
Note that the injection of $\mexpr_\mathit{pgm}$ into $\CESKKstart$, $(\tpl{\mexpr_\mathit{pgm},\bot,\epsilon},\bot,\mtime_0,\bot)$, trivially satisfies $\inv$.

The unrolling proposition is the following
\begin{mathpar}
  \inferrule{ }{\epsilon \in \unroll{\mktab}{\Halt}} \quad
  \inferrule{\makont \in \mktab(\mctx),
             \mkont \in \unroll{\mktab}{\makont}}
            {\kcons{\mkframe}{\mkont} \in \unroll{\mktab}{\kcons{\mkframe}{\mctx}}}
\end{mathpar}
\begin{theorem}[Correctness]\label{thm:pushdown-correct}
  For all expressions $\mexpr_\mathit{pgm}$,
  \begin{itemize}
  \item{{\bf Soundness: } %for all $\mstate\equiv\tpl{\mexpr,\maenv,\mkont},\mstate'\equiv{\mexpr',\maenv',\mkont'} \in \CESKt$,
        if $\mstate,\mstore,\mtime \stepto_{\CESKt} \mstate',\mstore',\mtime'$,
        %for all $\mktab,\makont$ if
        $\inv(\mstate\set{\mkont := \makont},\mstore,\mtime,\mktab)$,
        and $\mkont \in \unroll{\mktab}{\makont}$, then
        there are $\mktab',\makont'$ such that
        $\mstate\set{\mkont := \makont},\mstore,\mtime,\mktab \stepto_{\CESKKstart} \mstate'\set{\mkont := \makont'},\mstore',\mktab',\mtime'$ and $\mkont' \in \unroll{\mktab'}{\makont'}$}
  \item{{\bf Completeness:} if $\mastate,\mstore,\mtime,\mktab \stepto_{\CESKKstart} \mastate',\mstore',\mtime',\mktab'$
      and $\inv(\mastate,\mstore,\mtime,\mktab)$,
      for all $\mkont$, if $\mkont \in \unroll{\mktab}{\mastate.\makont}$ then
      there is a $\mkont'$ such that
      $\mastate\set{\makont := \mkont},\mstore,\mtime \stepto_{\CESKt}
       \mastate'\set{\makont := \mkont'},\mstore',\mtime'$ and
       $\mkont' \in \unroll{\mktab}{\mastate'.\makont}$.}
  \end{itemize}
\end{theorem}

\subsection{Engineered semantics for efficiency}
%%
We cover three optimizations that may be employed to accelerate the fixed-point computation.
\begin{enumerate}
\item{Observe that $\mktab$ can be made global with no loss in precision; it will not need to be stored in the frontier or set of seen states.}
\item{Continuations can be ``chunked'' more coarsely at function boundaries instead of at each frame in order to minimize table lookups.}
\item{Since evaluation is the same regardless of the stack, we can memoize results to short-circuit to the answer.}
\end{enumerate}
%
This last optimization will be covered in more detail in \autoref{sec:memo}.

Flow analyses commonly split control-flow graphs at function call boundaries to enable the combination of intra- and inter-procedural analyses.
%
In an abstract machines, this split looks like installing a continuation prompt at function calls.
%
We borrow a representation from literature on delimited continuations to split the continuation into two components: the continuation and meta-continuation.
%
Our delimiters are special since each continuation ``chunk'' until the next prompt has bounded length.
%
The bound is roughly the deepest nesting depth of an expression in functions' bodies.
%
Instead of ``continuation'' and ``meta-continuation'' then, we will use terminology from CFA2 and call the top chunk a ``local continuation,'' and the rest the ``continuation.''\footnote{Since the continuation is either $\Halt$ or a context, CFA2 calls these ``entries'' to mean execution entry into the program ($\Halt$) or a function ($\mctx$). One can also understand these as entries in a table ($\mktab$). We stay with the ``continuation'' nomenclature because they represent full continuations.}
%
%

\begin{figure}
  \centering
  \begin{align*}
    \mstate \in \sa{CEIK} &= \tpl{\mexpr,\menv,\mlkont,\mkont} \\
    \mlkont \in \LKont &= \Frame^* \\
    \makont \in \Kont &= \Context + \set{\Halt}
  \end{align*}
  \caption{$\CESIKKstart$ semantic spaces}
  \label{fig:pushdown-spaces}
\end{figure}

The resulting shuffling of the semantics to accommodate this new representation is in \autoref{fig:cesikkstart-semantics}.
%
The extension to $\mktab$ happens in a different rule -- function entry -- so the shape of the context changes to hold the function, argument, store and time.
%
We have a choice of whether to introduce an administrative step to dereference $\mktab$ once $\mlkont$ is empty, or to use a helper metafunction to describe a ``pop'' of both $\mlkont$ and $\mkont$.
%
Suppose we choose the second because the resulting semantics has a 1-to-1 correspondence with the previous semantics.
%
A first try might land us here:
\begin{align*}
  \pop(\kcons{\mkframe}{\mlkont},\makont,\mktab) &= \set{(\mkframe,\mlkont,\makont)} \\
  \pop(\epsilon,\mctx,\mktab) &= \setbuild{(\mkframe,\mlkont,\makont)}{(\kcons{\mkframe}{\mlkont}, \makont) \in \mktab(\mctx)}
\end{align*}
However, tail calls make the dereferenced $\mctx$ lead to $(\epsilon,\mctx')$.
%
Because abstraction makes the store grow monotonically in a finite space, it's possible that $\mctx' = \mctx$ and a naive recursive definition of $\pop$ will diverge chasing these contexts.
%
Now $\pop$ must save all the contexts it dereferences in order to guard against divergence.
%
So $\pop(\mlkont,\makont,\mktab) = \popaux(\mlkont,\makont,\mktab,\emptyset)$ where
\begin{align*}
  \popaux(\epsilon,\epsilon,\mktab,G) &= \emptyset \\
  \popaux(\kcons{\mkframe}{\mlkont},\makont,\mktab,G) &= \set{(\mkframe,\mlkont,\makont)} \\
  \popaux(\epsilon,\mctx,\mktab,G) &= \setbuild{(\mkframe,\mlkont,\makont)}{(\kcons{\mkframe}{\mlkont}, \makont) \in \mktab(\mctx)} \\
  &\cup \bigcup\limits_{\mctx' \in G'}\popaux(\epsilon,\mctx',\mktab,G\cup G') \\
  \text{where } G' &= \setbuild{\mctx'}{(\epsilon,\mctx') \in \mktab(\mctx)} \setminus G
\end{align*}

In practice, one would not expect $G$ to grow very large.
%
Had we chosen the first strategy, the issue of divergence is delegated to the machinery from the fixed-point computation.\footnote{CFA2 employs the first strategy and calls it ``transitive summaries.''}
%
However, when adding the administrative state, the ``seen'' check requires searching a far larger set than we would expect $G$ to be.

\begin{figure}
  \centering
  $\mastate,\mstore,\mtime,\mktab \stepto \mastate',\mstore',\tick(\mastate,\mstore,\mtime),\mktab'$ \quad $\maddr = \alloc(\mstate,\mstore,\mtime)$ \\
  \begin{tabular}{r|l}
    \hline\vspace{-3mm}\\
    $\tpl{\svar\mvar, \maenv, \mlkont, \makont}$
    &
    $\tpl{\mval, \maenv',\mlkont,\makont}$ if $(\mval,\menv') \in \mstore(\maenv(\mvar))$
    \\
% Application
    $\tpl{\sapp{\mexpri0}{\mexpri1},\maenv,\mlkont,\makont}$
    &
    $\tpl{\mexpri0,\maenv,\kcons{\appl{\mexpri1,\maenv}}{\mlkont},\makont}$
    \\
% Arg eval
    $\tpl{\mval,\maenv, \mlkont,\makont}$
    &
    $\tpl{\mexpr,\maenv',\kcons{\appr{\mval,\maenv}}{\mlkont'},\makont'}$ \\
    &
    if $\appl{\mexpr,\maenv'}, \mlkont',\makont' \in \pop(\mlkont,\makont,\mktab)$ \\
% Function call
    $\tpl{\mval,\maenv, \mlkont,\makont}$
    &
    $\tpl{\mexpr,\maenv'[\mvar\mapsto\maddr],\epsilon,\mctx}$ \\
    & if $\appr{\slam{\mvar}{\mexpr},\maenv'}, \mlkont', \makont' \in \pop(\mlkont,\makont,\mktab)$ \\
    where & $\mstore' = \joinm{\mstore}{\maddr}{(\mval,\maenv)}$ \\
    & $\mctx = (\mval,\maenv,\slam{\mvar}{\mexpr},\maenv',\mstore,\mtime)$ \\
    & $\mktab' = \joinm{\mktab}{\mctx}{(\mlkont,\makont)}$
  \end{tabular} \\
  Where $\mstore' = \mstore$ and $\mktab' = \mktab$ unless otherwise stated.
  \caption{$\CESIKKstart$ semantics}
  \label{fig:cesikkstart-semantics}
\end{figure}

\begin{align*}
  {\mathcal F}_{\mexpr}(S,R,F,\mktab) &= (S \cup F, R \cup R', F'\setminus S, \mktab') \\
  I &= \bigcup\limits_{s=(\mstate,\mstore,\mtime) \in F}{\setbuild{(\tpl{s,s'}, \mktab')}{s,\mktab \stepto s',\mktab'}} \\
  R' &= \pi_0 I \\
  F' &= \pi_1 R' \\
  \mktab' &= \bigsqcup\pi_1 I
\end{align*}
For a program $\mexpr$, we will say $(\emptyset,\emptyset,\set{\tpl{\mexpr,\bot,\epsilon,\Halt}},\bot)$ is the bottom element of ${\mathcal F}_{\mexpr}$'s domain.
%
The ``analysis'' then is then the pair of the $R$ and $\mktab$ components of $\lfp({\mathcal F}_{\mexpr})$.

The correctness argument for this semantics is not about single steps but instead about the entire relation that ${\mathcal F}$ computes.
%
The argument is that the $R$ and $\mktab$ components of the system represent a slice of the unbounded relation $\stepto_{\CESKt}$ (restricted to reachable states).
%
We will show that traces in any $n \in \nat$ times we \emph{unfold} $\stepto_{\CESKt}$ from the initial state, there is a corresponding $m$ applications of ${\mathcal F}$ that reify into a relation that exhibit the same trace.
%
Conversely, any trace in the reification of ${\mathcal F}_{\mexpr}^m(\bot)$ has the same trace in some $n$ unfoldings of $\stepto_{\CESKt}$.
%
For an arbitrary $\alloc$ function, we cannot expect ${\mathcal F}$ to have a fixed point, so this property is the best we can get.
%
For a finite $\alloc$ function, Kleene's fixed point theorem dictates there is a $m$ such that ${\mathcal F}_{\mexpr}^m(\bot)$ is a fixed point, so every trace in the reified relation is also a trace in an unbounded number of unfoldings of $\stepto_{\CESKt}$.
%
This is the corresponding completeness argument for the algorithm.

\begin{align*}
  \reachrestrict(\mstate_0, \stepto, 0) &= \setbuild{(\mstate_0,\mstate)}{\mstate_0 \stepto \mstate} \\
  \reachrestrict(\mstate_0, \stepto, n+1) &= \stepextend(\reachrestrict(\mstate_0,\stepto,n)) \\
  \textit{where } \stepextend(R) &= R \cup \setbuild{(\mstate,\mstate')}{(\_,\mstate) \in R, \mstate \stepto \mstate'}
\end{align*}
The reification simply realizes all possible complete continuations that a state could have, given $\mktab$:
\begin{mathpar}
  \inferrule{
  \tpl{(\tpl{\mexpr,\maenv,\makont},\mstore,\mtime),
      (\tpl{\mexpr',\maenv',\makont'},\mstore',\mtime')} \in R \\
  \mkont \in \tails{\mktab}{\makont}}
  {\tpl{\mexpr,\maenv,\append{\makont}{\mkont}},\mstore,\mtime \stepto_{\reify(S,F,R,\mktab)}
   \tpl{\mexpr',\maenv',\append{\makont'}{\mkont}},\mstore',\mtime'}
  % \reify(S,F,R,\mktab) &= \setbuild{}
  % {\\ &\phantom{= \{}
  %   \tpl{(\tpl{\mexpr,\maenv,\makont},\mstore,\mtime),
  %     (\tpl{\mexpr',\maenv',\makont'},\mstore',\mtime')} \in R,
  %   \\ &\phantom{= \{}
  %   \mkont \in \tails{\mktab}{\makont}}
\end{mathpar}
The additional judgment about tails is a variant of $\mathit{unroll}$ in order to get a common tail:
\begin{mathpar}
  \inferrule{ }{\epsilon \in \tails{\mktab}{\Halt}} \quad
  \inferrule{\makont \in \mktab(\mctx) \\
             \mkont \in \unroll{\mktab}{\makont}}
            {\mkont \in \tails{\mktab}{\kcons{\mkframe}{\mctx}}}
\end{mathpar}
\begin{theorem}[Correctness]
  For all $\mexpr_\mathit{pgm}$, let $\mstate_0 = \tpl{\mexpr_\mathit{pgm},\bot,\epsilon},\bot,\mtime_0$ in
  $\forall n \in \nat, \mstate,\mstate' \in \CESKt$:
  \begin{itemize}
  \item{if $(\mstate,\mstate') \in \reachrestrict(\mstate_0,\stepto_{\CESKt},n)$ then
      there is an $m$ such that $\mstate \stepto_{\reify({\mathcal F}_{\mexpr_\mathit{pgm}}^m(\bot))} \mstate'$}
  \item{if $\mstate \stepto_{\reify({\mathcal F}_{\mexpr_\mathit{pgm}}^n(\bot))} \mstate'$ then
      there is an $m$ such that $(\mstate,\mstate') \in \reachrestrict(\mstate_0,\stepto_{\CESKt},m)$}
  \end{itemize}
\end{theorem}
\begin{proof}
  By induction on $n$.
\end{proof}