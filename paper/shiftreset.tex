What happens when we apply the techniques of the previous sections to a semantics that treats continuations as first-class?
%
The glaring issue is that continuations become ``storeable'' and relevant to the execution of functions.
%
But, it was precisely the \emph{irrelevance} that allowed the separation of $\mstore$ and $\mktab$.
%
Specifically, the store components of continuations become elements of the store's codomain --- a recursion that can lead to an unbounded state space and therefore a non-terminating analysis.
%
We apply the AAM methodology to cut out the recursion; whenever a continuation is captured to go into the store, we allocate an address to approximate the store component of the continuation.
%%

%%
Where should these addresses be mapped?
%
We introduce a new environment, $\mmktab$, that maps these addresses to the stores they represent.
%
The stores that contain addresses in $\mmktab$ are then \emph{open}, and must be paired with $\mmktab$ to be \emph{closed}.
%
This poses the same problem as before with contexts in storeable continuations.
%
Therefore, we give up some precision to regain termination by \emph{flattening} these environments when we capture continuations.
%
Fresh allocation still maintains the concrete semantics, but we necessarily lose some ability to distinguish contexts in the abstract.
%%

\subsection{Case study: shift and reset}
%%
Our concrete test subject is the abstract machine for shift and reset, adapted from \citet{ianjohnson:Biernacki2006274} in the ``{\bf ev}al, {\bf co}ntinue'' style in \autoref{fig:shift-reset}.
%
The figure elides the rules for standard function calls.
%
The new additions to the state space are a new kind of value, $\vcomp{\mkont}$, and a \emph{meta-continuation}, $\mmkont \in \MKont = \Kont^*$ for separating continuations by their different prompts.
%
Composable continuations are indistinguishable from functions, so even though the meta-continuation is concretely a list of continuations, its conses are notated as function composition: $\mkapp{\mkont}{\mmkont}$.

\begin{figure}
  \centering
  $\mstate \stepto \mstate'$ \\
  \begin{tabular}{r|l}%{r|ll}
    \hline
% Reset
    $\ev{\sreset{\mexpr}, \menv, \mstore,\mkont, \mmkont}$
    &
    $\ev{\mexpr, \menv, \mstore,\epsilon, \mkapp{\mkont}{\mmkont}}$
%    & \textsc{[push prompt]}
    \\
% Pop prompt
    $\co{\epsilon, \mkapp{\mkont}{\mmkont}, \mval,\mstore}$
    &
    $\co{\mkont, \mmkont, \mval,\mstore}$
%    & \textsc{[pop prompt]}
    \\
% Shift
    $\ev{\sshift{\mvar}{\mexpr}, \menv, \mstore,\mkont, \mmkont}$
    &
    $\ev{\mexpr, \extm{\menv}{\mvar}{\maddr},\mstore',\epsilon,\mmkont}$
    \\
    where & $\mstore' = \joinm{\mstore}{\maddr}{\vcomp{\mkont}}$
%    & \textsc{[capture continuation]}
    \\
% continuation call
    $\co{\kcons{\kfn{\vcomp{\mkont'}}}{\mkont}, \mmkont, \mval,\mstore}$
    &
    $\co{\mkont', \mkapp{\mkont}{\mmkont}, \mval,\mstore}$
%    & \textsc{[compose continuation]}
  \end{tabular}  
  \caption{Machine semantics for shift/reset}
  \label{fig:shift-reset}
\end{figure}
%%

\subsection{Reformulated with continuation stores}
%
The machine in \autoref{fig:shift-reset} is transformed now to have three new tables: one for continuations, one as discussed in the section beginning to close stored continuations, and one for meta-continuations.
%
The first is like previous sections, albeit continuations may now have the approximate form that is storable.
%
The meta-continuation table is much like the continuation table of previous sections because they are not storable.
%
Meta-continuations do not have simple syntactic strategies for bounding their size, so we choose to bound them to size 0.
%
They could be paired with lists of $\sa{Kont}$ bounded at an arbitrary $n \in \nat$, but we simplify for presentation.

Contexts for continuations are still at function application, but now contain the $\mmktab$.
%
Contexts for meta-continuations are in two places: manual prompt introduction via {\tt reset}, or via continuation invocation.
%
At continuation capture time, continuation contexts are approximated to remove $\mastore$ and $\mmktab$ components.
%
The different context spaces are thus:
\begin{align*}
  \msctx \in \ExactContext &::= \tpl{\maval,\maval,\mastore,\mmktab} \\
  \mactx \in \sa{Context} &::= \tpl{\maval,\maval,\maddr} \\
  \mctx \in \Context &::= \mactx \alt \msctx \\
  \mmctx \in \MContext &::= \tpl{\mexpr,\menv,\mastore,\mmktab}
                       \alt \tpl{\mvkont, \mval, \mastore, \mmktab} \\
\end{align*}
%


\begin{figure}
  \centering
  \begin{align*}
    \mastate \in \sa{SR} &::= \ev{\mexpr,\menv,\mastore,\mmktab,\makont,\mamkont} \alt \co{\makont,\mamkont,\maval,\mastore,\mmktab} \\
    \State &::= \mastate,\mktab_{\makont},\mktab_{\mamkont} \\
    \mmktab \in \MKTab &= \Addr \finto \wp(\Store) \\
    \makont \in \sa{Kont} &::= \epsilon \alt \kcons{\mkframe}{\mctx} \alt \mctx \\
    \mamkont \in \sa{MKont} &::= \epsilon \alt \mmctx \\
    \mvkont \in \VKont &::= \epsilon \alt \mactx \\
    \mktab_{\makont} \in \KStore &= \ExactContext \finto \wp(\sa{Kont}) \\
    \mktab_{\mamkont} \in \MKStore &= \MContext \finto \wp(\sa{Kont} \times \sa{MKont}) \\
    \maval \in \sa{Value} &::= \mvkont \alt (\mlam,\menv) \\
  \end{align*}
  \caption{Shift/reset abstract semantic spaces}
  \label{fig:shiftreset-spaces}
\end{figure}
%
The approximation and flattening happens in $\approximate$:
\begin{equation*}
  \approximate : \MKTab \times \Addr \times \SKont \to \MKTab \times \VKont
\end{equation*}
\begin{align*}
  \approximate(\mmktab,\maddr,\epsilon) &= \mmktab,\epsilon \\
  \approximate(\mmktab,\maddr,\kcons{\mkframe}{\tpl{\maval_f,\maval_a,\mastore,\mmktab'}}) &= \joinm{\mmktab\sqcup\mmktab'}{\maddr}{\mastore},\kcons{\mkframe}{\tpl{\maval_f,\maval_a,\maddr}} \\
  \approximate(\mmktab,\maddr,\kcons{\mkframe}{\tpl{\maval_f,\maval_a,\maddralt}}) &= \joinm{\mmktab}{\maddr}{\mmktab(\maddralt)},\kcons{\mkframe}{\tpl{\maval_f,\maval_a,\maddr}}
\end{align*}
The second case is where continuation closures get flattened together.
%
The third case is when an already approximate continuation is approximated: the approximation is inherited.
%
Approximating the context and allocating the continuation in the store require two addresses, so we relax the specification of $\alloc$ to allow multiple address allocations in this case.

Each of the four rules of the original shift/reset machine has a corresponding rule that we explain piecemeal.
%
We use the above $\approximate$ function in the rule for continuation capture, as modified here.
%
\begin{equation*}\ev{\sshift{\mvar}{\mexpr},\menv,\mastore,\mmktab,\makont,\mamkont} \kindastepto
  \ev{\mexpr,\menv',\mastore',\mmktab',\epsilon,\mamkont}
\end{equation*}
where
\begin{align*}
  (\maddr,\maddr') &= \alloc(\mastate,\mktab_\makont,\mktab_\mamkont) & \menv' &= \extm{\menv}{\mvar}{\maddr} \\
  (\mvkont,\mmktab') &= \approximate(\mmktab,\maddr',\makont) &
  \mastore' &= \joinm{\mastore}{\maddr}{\mvkont}
\end{align*}

The rule for {\tt reset} stores the continuation and meta-continuation in $\mktab_{\mamkont}$:
\begin{align*}
\ev{\sreset{\mexpr},\menv,\mastore,\mmktab,\makont,\mamkont} &\kindastepto
  \ev{\mexpr,\menv,\mastore,\mmktab,\epsilon,\mmctx},\joinm{\mktab_{\mamkont}}{\mmctx}{(\makont,\mamkont)} \\
\text{where } \mmctx &= \tpl{\mexpr,\menv,\mastore,\mmktab}
\end{align*}

The prompt-popping rule simply dereferences $\mktab_{\mamkont}$:
\begin{align*}
  \co{\epsilon,\mmctx,\maval,\mastore,\mmktab} &\kindastepto \co{\makont,\mamkont,\maval,\mastore,\mmktab} \text{ if } (\makont,\mamkont) \in \mktab_{\mamkont}(\mmctx)
\end{align*}

The continuation installation rule extends $\mktab_{\mamkont}$ at the different context:
\begin{align*}
  \co{\makont,\mamkont,\maval,\mastore,\mmktab} &\kindastepto \co{\mvkont,\mmctx,\maval,\mastore,\mmktab},\joinm{\mktab_{\mamkont}}{\mmctx}{(\makont',\mamkont)} \\ 
\text{if } & (\appr{\mvkont},\makont') \in \pop(\mktab_{\makont},\mmktab, \makont) \\
\text{where } \mmctx &= \mvkont,\maval,\mastore,\mmktab
\end{align*}
Again we have a metafunction $\pop$, but this time to interpret approximated continuations:
\begin{align*}
  \pop(\mktab_{\makont}, \mmktab, \makont) &= \popaux(\makont,\emptyset) \\
  \text{where } 
   \popaux(\epsilon, G) &= \emptyset \\
   \popaux(\kcons{\mkframe}{\mctx}, G) &= \set{(\mkframe,\mctx)} \\
   \popaux(\mctx, G) &= \bigcup\limits_{\makont \in G'}(\popaux(\makont, G\cup G')) \\
    \text{where } G' &= \bigcup\limits_{\msctx \in I(\mctx)}{\mktab_{\makont}(\msctx)} \setminus G \\
  I(\msctx) &= \set{\msctx} \\
  I(\tpl{\maval_f,\maval_a,\maddr}) &=
  \setbuild{\tpl{\maval_f,\maval_a,\mastore,\mmktab'} \in \dom(\mktab_{\makont})}
           {\mastore \in \mmktab(\maddr),
            \mmktab' \sqsubseteq \mmktab}
\end{align*}
Notice that since we flatten $\mmktab$s together, we need to compare for containment rather than for equality (in $I$).
\subsection{Correctness}
We suppose a store-allocating timestamped version of the semantics in \autoref{fig:shift-reset}, called $\SRSt$.
%
We impose an order on values since stored continuations are more approximate in the analysis than in $\SRSt$:
\begin{mathpar}
  \inferrule{ }{\mval \sqsubseteq_{\mktab,\mmktab} \mval} \quad
  \inferrule{\mkont \in \unroll{\mktab,\mmktab}{\mvkont}}
            {\vcomp{\mkont} \sqsubseteq_{\mktab,\mmktab} \mvkont} \quad
  \inferrule{\forall \mval\in\mstore(\maddr).
             \exists \maval\in\mastore(\maddr).
             \mval \sqsubseteq_{\mktab,\mmktab} \maval}
            {\mstore \sqsubseteq_{\mktab,\mmktab} \mastore} \\
  \inferrule{\mkont \sqsubseteq \unroll{\mktab_{\makont},\mmktab}{\makont} \\
             \mmkont \sqsubseteq \unrollC{\mktab_{\makont},\mktab_{\mamkont},\mmktab}{\mamkont} \\
             \mstore \sqsubseteq_{\mktab_{\makont},\mmktab} \mastore}
            {\ev{\mexpr,\menv,\mstore,\mkont,\mmkont} \sqsubseteq
             \ev{\mexpr,\menv,\mastore, \mmktab,\makont,\mamkont}, \mktab_{\makont}, \mktab_{\mamkont}} \\
  \inferrule{\mval \sqsubseteq_{\mktab_{\makont},\mmktab} \maval \\
             \mkont \sqsubseteq \unroll{\mktab_{\makont},\mmktab}{\makont} \\
             \mmkont \sqsubseteq \unrollC{\mktab_{\makont},\mktab_{\mamkont},\mmktab}{\mamkont} \\
             \mstore \sqsubseteq_{\mktab_{\makont},\mmktab} \mastore}
            {\co{\mkont,\mmkont,\mval,\mstore} \sqsubseteq
             \co{\makont,\mamkont,\maval,\mastore, \mmktab}, \mktab_{\makont}, \mktab_{\mamkont}}
\end{mathpar}
Unrolling differs from the previous sections because the values in frames can be approximate.
%
Thus, instead of expecting the exact continuation to be in the unrolling, we have a judgment that an unrolling approximates a given continuation in \autoref{fig:cont-order} (note we reuse $I$ from $\popaux$'s definition).

\begin{figure}
  \centering
  \begin{mathpar}
    \inferrule{ }{\appl{\mexpr,\menv} \sqsubseteq_{\mktab,\mmktab}
      \appl{\mexpr,\menv}} \quad \inferrule{\mval
      \sqsubseteq_{\mktab,\mmktab}{\maval}}
    {\appr{\mval} \sqsubseteq_{\mktab,\mmktab} \appr{\maval}} \\
    \inferrule{ }{\epsilon \sqsubseteq
      \unroll{\mktab,\mmktab}{\epsilon}} \quad
    \inferrule{\mkframe \sqsubseteq_{\mktab,\mmktab} \makframe \\
      \mkont \sqsubseteq \unroll{\mktab,\mmktab}{\mctx}}
    {\kcons{\mkframe}{\mkont} \sqsubseteq
      \unroll{\mktab,\mmktab}{\kcons{\makframe}{\mctx}}}
    \\
    \inferrule{\makont \in \mktab(\msctx) \quad
      \mkont \sqsubseteq \unroll{\mktab,\mmktab}{\makont}} {\mkont
      \sqsubseteq \unroll{\mktab,\mmktab}{\msctx}}
    \quad
    \inferrule{\msctx \in I(\mktab,\mmktab,\mactx) \quad
      \mkont \sqsubseteq \unroll{\mktab,\mmktab}{\msctx}} {\mkont
      \sqsubseteq \unroll{\mktab,\mmktab}{\mactx}}
    \\
    \inferrule{ }
              {\epsilon \sqsubseteq \unrollC{\mktab_{\makont},\mktab_{\mamkont},\mmktab}{\epsilon}}
    \\
    \inferrule{(\makont,\mamkont) \in \mktab_{\mamkont}(\mmctx) \\
               \mkont \sqsubseteq \unroll{\mktab_{\makont},\mmktab}{\makont} \\
               \mmkont \sqsubseteq \unrollC{\mktab_{\makont},\mktab_{\mamkont},\mmktab}{\mamkont}}
              {\mkapp{\mkont}{\mmkont} \sqsubseteq \unrollC{\mktab_{\makont},\mktab_{\mamkont},\mmktab}{\mmctx}}
  \end{mathpar}
  
  \caption{Order on (meta-)continuations}
\label{fig:cont-order}
\end{figure}
\begin{theorem}[Soundness]
  If $\somestate \stepto_{\SRSt} \nextstate$, and $\somestate \sqsubseteq \someotherstate$ then there is $\nextotherstate$ such that $\someotherstate \stepto_{\SRSChKKt} \nextotherstate$ and
$\nextstate \sqsubseteq \nextotherstate$.
\end{theorem}

To substantiate our claim that fresh allocation leads to an exact semantics, we need to show an invariant on our continuation stores: no circular references, all mappings are to singleton sets, and all contexts have unique stores unless all components of the context are the same except for the expression and timestamp.
\begin{mathpar}
  \inferrule{\wf(\mktab_\makont) \\ \wfC(\mktab_\makont,\mktab_\mamkont) \\
\forall \mctx\in\dom(\mktab_\makont). |\mktab_\makont(\mctx)|=1
\\
\forall \mmctx\in\dom(\mktab_\mamkont). |\mktab_\mamkont(\mmctx)|=1 \\
\forall \mctx\neq\mctx'. \compatible{\mctx}{\mctx'} \vee \pi_2(\mctx) \neq \pi_2(\mctx') \\
\forall \mmctx\neq\mmctx'. \compatible{\mmctx}{\mmctx'} \vee \pi_2(\mmctx) \neq \pi_2(\mmctx') \\
}{\inv_{\fresh}(\tpl{\mexpr,\menv, \mastore, \mmktab,\makont,\mamkont}, \mktab_{\makont}, \mktab_{\mamkont})}
 \\
\inferrule{ }{\compatible{\tpl{\_,\menv,\mastore,\_}}{\tpl{\_,\menv,\mastore,\_}}} \quad
\inferrule{ }{\compatible{\tpl{\_,\menv,\mastore,\mmktab,\_}}{\tpl{\_,\menv,\mastore,\mmktab,\_}}}
\end{mathpar}
The $\wf$ and $\wfC$ propositions describe the well-founded order on the continuation stores, assuming the codomains contain only singleton sets.
\begin{mathpar}
  \inferrule{ }{\wf(\bot)} \quad
  \inferrule{\makont \sqsubseteq \mktab_{\makont}|_{\overline{\mctx}}}
            {\wf(\extm{\mktab_{\makont}}{\mctx}{\set{\makont}})} \\
  \inferrule{ }{\wfC(\bot)} \quad \inferrule{(\makont,\mamkont) \sqsubseteq \mktab_{\makont},\mktab_{\mamkont}|_{\overline{\mmctx}}}
                                            {\wfC(\mktab_{\makont},\extm{\mktab_{\mamkont}}{\mmctx}{\set{(\makont,\mamkont)}})} \\
\inferrule{ }{\epsilon \sqsubseteq \mktab_{\makont}} \quad
\inferrule{\mctx \in \dom(\mktab_\makont)}
          {\kcons{\mkframe}{\mctx} \sqsubseteq \mktab_{\makont}} \\
\inferrule{\makont \sqsubseteq \mktab_\makont}
          {(\makont,\epsilon) \sqsubseteq \mktab_\makont,\mktab_{\mamkont}} \quad
\inferrule{\makont \sqsubseteq \mktab_\makont \\
           \mmctx \in \dom(\mktab_\mamkont)}
          {(\makont,\mmctx) \sqsubseteq \mktab_\makont,\mktab_\mamkont}
\end{mathpar}

\begin{lemma}[Freshness invariant]
  If $\alloc$ produces fresh addresses, $\inv_{\fresh}(\mastate,\mktab_\makont,\mktab_\mamkont)$ and
$\mastate,\mktab_{\makont},\mktab_{\mamkont} \stepto
\mastate',\mktab'_{\makont},\mktab'_{\mamkont}$ then
$\inv_{\fresh}(\mastate',\mktab'_{\makont},\mktab'_{\mamkont})$.
\end{lemma}
\begin{theorem}[Complete for fresh allocation]
  If $\alloc$ produces fresh addresses then the resulting semantics is complete with respect to states satisfying the invariant.
\end{theorem}
