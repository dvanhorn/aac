In \autoref{sec:pushdown} we showed how to get a pushdown abstraction by separating continuations from the heap that stores values.
%
This separation breaks down when continuations themselves become values via first-class control operators.
%
The glaring issue is that continuations become ``storeable'' and relevant to the execution of functions.
%
But, it was precisely the \emph{irrelevance} that allowed the separation of $\mstore$ and $\mktab$.
%
Specifically, the store components of continuations become elements of the store's codomain --- a recursion that can lead to an unbounded state space and therefore a non-terminating analysis.
%
We apply the AAM methodology to cut out the recursion; whenever a continuation is captured to go into the store, we allocate an address to approximate the store component of the continuation.
%%

%%
We introduce a new environment, $\mmktab$, that maps these addresses to the stores they represent.
%
The stores that contain addresses in $\mmktab$ are then \emph{open}, and must be paired with $\mmktab$ to be \emph{closed}.
%
This poses the same problem as before with contexts in storeable continuations.
%
Therefore, we give up some precision to regain termination by \emph{flattening} these environments when we capture continuations.
%
Fresh allocation still maintains the concrete semantics, but we necessarily lose some ability to distinguish contexts in the abstract.
%%

\subsection{Case study of first-class control: shift and reset}
%%
We choose to study {\tt shift} and {\tt reset} because delimited continuations have proven useful for implementing web servers~\citep{plt-webserver}, providing processes isolation in operating systems~\citep{ianjohnson:Kiselyov2007Delimited}, representing computational effects~\citep{ianjohnson:Filinski1994Representing}, modularly implementing error-correcting parsers~\citep{ianjohnson:DBLP:conf/icfp/ShiversT11}, and finally undelimited continuations are \emph{pass\'e} for good reason~\citep{ianjohnson:kiselyov:against-callcc}.
%
Even with all their uses, however, their semantics can yield control-flow possibilities that surprise their users.
%
A \emph{precise} static analysis that illuminates their behavior is then a valuable tool.
%

Our concrete test subject is the abstract machine for shift and reset adapted from \citet{ianjohnson:Biernacki2006274} in the ``{\bf ev}al, {\bf co}ntinue'' style in \autoref{fig:shift-reset}.
%
The figure elides the rules for standard function calls.
%
The new additions to the state space are a new kind of value, $\vcomp{\mkont}$, and a \emph{meta-continuation}, $\mmkont \in \MKont = \Kont^*$ for separating continuations by their different prompts.
%
Composable continuations are indistinguishable from functions, so even though the meta-continuation is concretely a list of continuations, its conses are notated as function composition: $\mkapp{\mkont}{\mmkont}$.

\begin{figure}
  \centering
  $\mstate \stepto \mstate'$ \\
  \begin{tabular}{r|l}%{r|ll}
    \hline
% Reset
    $\ev{\sreset{\mexpr}, \menv, \mstore,\mkont, \mmkont}$
    &
    $\ev{\mexpr, \menv, \mstore,\epsilon, \mkapp{\mkont}{\mmkont}}$
%    & \textsc{[push prompt]}
    \\
% Pop prompt
    $\co{\epsilon, \mkapp{\mkont}{\mmkont}, \mval,\mstore}$
    &
    $\co{\mkont, \mmkont, \mval,\mstore}$
%    & \textsc{[pop prompt]}
    \\
% Shift
    $\ev{\sshift{\mvar}{\mexpr}, \menv, \mstore,\mkont, \mmkont}$
    &
    $\ev{\mexpr, \extm{\menv}{\mvar}{\maddr},\mstore',\epsilon,\mmkont}$
    \\
    where & $\mstore' = \joinm{\mstore}{\maddr}{\vcomp{\mkont}}$
%    & \textsc{[capture continuation]}
    \\
% continuation call
    $\co{\kcons{\kfn{\vcomp{\mkont'}}}{\mkont}, \mmkont, \mval,\mstore}$
    &
    $\co{\mkont', \mkapp{\mkont}{\mmkont}, \mval,\mstore}$
%    & \textsc{[compose continuation]}
  \end{tabular}  
  \caption{Machine semantics for shift/reset}
  \label{fig:shift-reset}
\end{figure}
%%

\subsection{Reformulated with continuation stores}
%
The machine in \autoref{fig:shift-reset} is transformed now to have three new tables: one for continuations, one as discussed in the section beginning to close stored continuations, and one for meta-continuations.
%
The first is like previous sections, albeit continuations may now have the approximate form that is storeable.
%
The meta-continuation table is much like the continuation table of previous sections because they are not storeable.
%
Meta-continuations do not have simple syntactic strategies for bounding their size, so we choose to bound them to size 0.
%
They could be paired with lists of $\sa{Kont}$ bounded at an arbitrary $n \in \nat$, but we simplify for presentation.

Contexts for continuations are still at function application, but now contain the $\mmktab$.
%
Contexts for meta-continuations are in two places: manual prompt introduction via {\tt reset}, or via continuation invocation.
%
At continuation capture time, continuation contexts are approximated to remove $\mastore$ and $\mmktab$ components.
%
The different context spaces are thus:
\begin{align*}
  \msctx \in \ExactContext &::= \tpl{\mexpr,\menv,\mastore,\mmktab} \\
  \mactx \in \sa{Context} &::= \tpl{\maval,\maval,\maddr} \\
  \mctx \in \Context &::= \mactx \alt \msctx \\
  \mmctx \in \MContext &::= \tpl{\mexpr,\menv,\mastore,\mmktab}
                       \alt \tpl{\mvkont, \maval, \mastore, \mmktab} \\
\end{align*}
%


\begin{figure}
  \centering
  \begin{align*}
    \mastate \in \sa{SR} &::= \ev{\mexpr,\menv,\mastore,\mmktab,\makont,\mamkont} \alt \co{\makont,\mamkont,\maval,\mastore,\mmktab} \\
    \State &::= \mastate,\mktab_{\makont},\mktab_{\mamkont} \\
    \mmktab \in \MKTab &= \Addr \finto \wp(\Store) \\
    \makont \in \sa{Kont} &::= \epsilon \alt \kcons{\mkframe}{\mctx} \alt \mctx \\
    \mamkont \in \sa{MKont} &::= \epsilon \alt \mmctx \\
    \mvkont \in \VKont &::= \epsilon \alt \mactx \\
    \mktab_{\makont} \in \KStore &= \ExactContext \finto \wp(\sa{Kont}) \\
    \mktab_{\mamkont} \in \MKStore &= \MContext \finto \wp(\sa{Kont} \times \sa{MKont}) \\
    \maval \in \sa{Value} &::= \mvkont \alt (\mlam,\menv) \\
  \end{align*}
  \caption{Shift/reset abstract semantic spaces}
  \label{fig:shiftreset-spaces}
\end{figure}
%
The approximation and flattening happens in $\approximate$:
\begin{equation*}
  \approximate : \MKTab \times \Addr \times \SKont \to \MKTab \times \VKont
\end{equation*}
\begin{align*}
  \approximate(\mmktab,\maddr,\epsilon) &= \mmktab,\epsilon \\
  \approximate(\mmktab,\maddr,\kcons{\mkframe}{\tpl{\maval_f,\maval_a,\mastore,\mmktab'}}) &= \joinm{\mmktab\sqcup\mmktab'}{\maddr}{\mastore},\kcons{\mkframe}{\tpl{\maval_f,\maval_a,\maddr}} \\
  \approximate(\mmktab,\maddr,\kcons{\mkframe}{\tpl{\maval_f,\maval_a,\maddralt}}) &= \joinm{\mmktab}{\maddr}{\mmktab(\maddralt)},\kcons{\mkframe}{\tpl{\maval_f,\maval_a,\maddr}}
\end{align*}
The second case is where continuation closures get flattened together.
%
The third case is when an already approximate continuation is approximated: the approximation is inherited.
%
Approximating the context and allocating the continuation in the store require two addresses, so we relax the specification of $\alloc$ to allow multiple address allocations in this case.

Each of the four rules of the original shift/reset machine has a corresponding rule that we explain piecemeal.
%
We will use $\kindastepto$ for steps that do not modify the continuation stores for notational brevity.
%
We use the above $\approximate$ function in the rule for continuation capture, as modified here.
%
\begin{equation*}\ev{\sshift{\mvar}{\mexpr},\menv,\mastore,\mmktab,\makont,\mamkont} \kindastepto
  \ev{\mexpr,\menv',\mastore',\mmktab',\epsilon,\mamkont}
\end{equation*}
where
\begin{align*}
  (\maddr,\maddr') &= \alloc(\mastate,\mktab_\makont,\mktab_\mamkont) & \menv' &= \extm{\menv}{\mvar}{\maddr} \\
  (\mvkont,\mmktab') &= \approximate(\mmktab,\maddr',\makont) &
  \mastore' &= \joinm{\mastore}{\maddr}{\mvkont}
\end{align*}

The rule for {\tt reset} stores the continuation and meta-continuation in $\mktab_{\mamkont}$:
\begin{align*}
\ev{\sreset{\mexpr},\menv,\mastore,\mmktab,\makont,\mamkont},\mktab_\makont,\mktab_\mamkont &\stepto
  \ev{\mexpr,\menv,\mastore,\mmktab,\epsilon,\mmctx},\mktab_\makont,\mktab_\mamkont' \\
  \text{where } \mmctx &= \tpl{\mexpr,\menv,\mastore,\mmktab} \\
                \mktab_\mamkont &= \joinm{\mktab_{\mamkont}}{\mmctx}{(\makont,\mamkont)}
\end{align*}

The prompt-popping rule simply dereferences $\mktab_{\mamkont}$:
\begin{align*}
  \co{\epsilon,\mmctx,\maval,\mastore,\mmktab} &\kindastepto \co{\makont,\mamkont,\maval,\mastore,\mmktab} \text{ if } (\makont,\mamkont) \in \mktab_{\mamkont}(\mmctx)
\end{align*}

The continuation installation rule extends $\mktab_{\mamkont}$ at the different context:
\begin{align*}
  \co{\makont,\mamkont,\maval,\mastore,\mmktab},\mktab_\makont,\mktab_\mamkont &\stepto \co{\mvkont,\mmctx,\maval,\mastore,\mmktab},\mktab_\makont,\mktab_\mamkont' \\ 
\text{if } & (\appr{\mvkont},\makont') \in \pop(\mktab_{\makont},\mmktab, \makont) \\
\text{where } \mmctx &= \mvkont,\maval,\mastore,\mmktab \\
              \mktab_\mamkont &= \joinm{\mktab_{\mamkont}}{\mmctx}{(\makont',\mamkont)}
\end{align*}
Again we have a metafunction $\pop$, but this time to interpret approximated continuations:
\begin{align*}
  \pop(\mktab_{\makont}, \mmktab, \makont) &= \popaux(\makont,\emptyset) \\
  \text{where } 
   \popaux(\epsilon, G) &= \emptyset \\
   \popaux(\kcons{\mkframe}{\mctx}, G) &= \set{(\mkframe,\mctx)} \\
   \popaux(\mctx, G) &= \bigcup\limits_{\makont \in G'}(\popaux(\makont, G\cup G')) \\
    \text{where } G' &= \bigcup\limits_{\msctx \in I(\mctx)}{\mktab_{\makont}(\msctx)} \setminus G \\
  I(\msctx) &= \set{\msctx} \\
  I(\tpl{\maval_f,\maval_a,\maddr}) &=
  \setbuild{\tpl{\maval_f,\maval_a,\mastore,\mmktab'} \in \dom(\mktab_{\makont})}
           {\mastore \in \mmktab(\maddr),
            \mmktab' \sqsubseteq \mmktab}
\end{align*}
Notice that since we flatten $\mmktab$s together, we need to compare for containment rather than for equality (in $I$).

\paragraph{Comparison to CPS transform to remove {\tt shift} and {\tt reset}:}{
We lose precision if we use a CPS transform to compile away {\tt shift} and {\tt reset} forms, because variables are treated less precisely than continuations.
%
%In pushdown analysis, we track function return points with entire calling contexts rather than the $k$-CFA way of allocating the continuation in the heap at some lower-precision address, like a variable.
%
%In our summarizing analysis of delimited composable control, we get added precision for {\tt reset}, {\tt shift}, and continuation invocation points.
%
Consider the following program and its CPS transform for comparison:
% \begin{lstlisting}[mathescape]
% (let* ([id ($\lambda$ (x) x)]
%        [f ($\lambda$ (y) (shift k (k (k y))))]
%        [g ($\lambda$ (z) (reset (id (f z))))])
%   (<= (g 0) (g 1)))
% \end{lstlisting}
\begin{small}
\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{let*}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{[}\RktSym{id}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{$\lambda$}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{x}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{x}\RktPn{)}\RktPn{]}

\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktPn{[}\RktSym{f}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{$\lambda$}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{y}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{shift}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{k}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{k}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{k}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{y}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{]}

\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktPn{[}\RktSym{g}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{$\lambda$}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{z}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{reset}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{id}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{f}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{z}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{]}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{$\le$}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{g}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{0}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{g}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{1}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}

% \begin{lstlisting}[mathescape]
% (let* ([id ($\lambda$ (x k) (k x))]
%        [f ($\lambda$ (y j) (j (j y)))]
%        [g ($\lambda$ (z h) (h (f z ($\lambda$ (fv) (id fv ($\lambda$ (i) i))))))])
%   (g 0 ($\lambda$ (g0v) (g 1 ($\lambda$ (g1v) (<= g0v g1v))))))
% \end{lstlisting}
\begin{SCodeFlow}\begin{RktBlk}\begin{SingleColumn}\RktPn{(}\RktSym{let*}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktPn{[}\RktSym{id}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{$\lambda$}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{x}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{k}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{k}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{x}\RktPn{)}\RktPn{)}\RktPn{]}

\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktPn{[}\RktSym{f}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{$\lambda$}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{y}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{j}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{j}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{j}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{y}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{]}

\mbox{\hphantom{\Scribtexttt{xxxxxxx}}}\RktPn{[}\RktSym{g}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{$\lambda$}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{z}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{h}\RktPn{)}
\\\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxx}}}\RktPn{(}\RktSym{h}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{f}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{z}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{$\lambda$}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{fv}\RktPn{)}
\\\mbox{\hphantom{\Scribtexttt{xxxxxxxxxxxxxxxxxxxx}}}\RktPn{(}\RktSym{id}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{fv}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{$\lambda$}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{i}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{i}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{]}\RktPn{)}

\mbox{\hphantom{\Scribtexttt{xx}}}\RktPn{(}\RktSym{g}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{0}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{$\lambda$}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{g0v}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{g}\mbox{\hphantom{\Scribtexttt{x}}}\RktVal{1}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{$\lambda$}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{g1v}\RktPn{)}\mbox{\hphantom{\Scribtexttt{x}}}\RktPn{(}\RktSym{$\le$}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{g0v}\mbox{\hphantom{\Scribtexttt{x}}}\RktSym{g1v}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\RktPn{)}\end{SingleColumn}\end{RktBlk}\end{SCodeFlow}
\end{small}
The $\CESKKstart$ machine with a monovariant allocation strategy will predict the CPS'd version returns true or false.
%
In analysis literature, ``monovariant'' means variables get one address, namely themselves.
%
Our specialized analysis for delimited control will predict the non-CPS'd version returns true.}

\subsection{Correctness}
We suppose a store-allocating timestamped version of the semantics in \autoref{fig:shift-reset}, called $\SRSt$.
%
We impose an order on values since stored continuations are more approximate in the analysis than in $\SRSt$:
\begin{mathpar}
  \inferrule{ }{\mval \sqsubseteq_{\mktab,\mmktab} \mval} \quad
  \inferrule{\mkont \in \unroll{\mktab,\mmktab}{\mvkont}}
            {\vcomp{\mkont} \sqsubseteq_{\mktab,\mmktab} \mvkont} \quad
  \inferrule{\forall \mval\in\mstore(\maddr).
             \exists \maval\in\mastore(\maddr).
             \mval \sqsubseteq_{\mktab,\mmktab} \maval}
            {\mstore \sqsubseteq_{\mktab,\mmktab} \mastore} \\
  \inferrule{\mkont \sqsubseteq \unroll{\mktab_{\makont},\mmktab}{\makont} \\
             \mmkont \sqsubseteq \unrollC{\mktab_{\makont},\mktab_{\mamkont},\mmktab}{\mamkont} \\
             \mstore \sqsubseteq_{\mktab_{\makont},\mmktab} \mastore}
            {\ev{\mexpr,\menv,\mstore,\mkont,\mmkont} \sqsubseteq
             \ev{\mexpr,\menv,\mastore, \mmktab,\makont,\mamkont}, \mktab_{\makont}, \mktab_{\mamkont}} \\
  \inferrule{\mval \sqsubseteq_{\mktab_{\makont},\mmktab} \maval \\
             \mkont \sqsubseteq \unroll{\mktab_{\makont},\mmktab}{\makont} \\
             \mmkont \sqsubseteq \unrollC{\mktab_{\makont},\mktab_{\mamkont},\mmktab}{\mamkont} \\
             \mstore \sqsubseteq_{\mktab_{\makont},\mmktab} \mastore}
            {\co{\mkont,\mmkont,\mval,\mstore} \sqsubseteq
             \co{\makont,\mamkont,\maval,\mastore, \mmktab}, \mktab_{\makont}, \mktab_{\mamkont}}
\end{mathpar}
Unrolling differs from the previous sections because the values in frames can be approximate.
%
Thus, instead of expecting the exact continuation to be in the unrolling, we have a judgment that an unrolling approximates a given continuation in \autoref{fig:cont-order} (note we reuse $I$ from $\popaux$'s definition).

\begin{figure}
  \centering
  \begin{mathpar}
    \inferrule{ }{\appl{\mexpr,\menv} \sqsubseteq_{\mktab,\mmktab}
      \appl{\mexpr,\menv}} \quad \inferrule{\mval
      \sqsubseteq_{\mktab,\mmktab}{\maval}}
    {\appr{\mval} \sqsubseteq_{\mktab,\mmktab} \appr{\maval}} \\
    \inferrule{ }{\epsilon \sqsubseteq
      \unroll{\mktab,\mmktab}{\epsilon}} \quad
    \inferrule{\mkframe \sqsubseteq_{\mktab,\mmktab} \makframe \\
      \mkont \sqsubseteq \unroll{\mktab,\mmktab}{\mctx}}
    {\kcons{\mkframe}{\mkont} \sqsubseteq
      \unroll{\mktab,\mmktab}{\kcons{\makframe}{\mctx}}}
    \\
    \inferrule{\makont \in \mktab(\msctx) \quad
      \mkont \sqsubseteq \unroll{\mktab,\mmktab}{\makont}} {\mkont
      \sqsubseteq \unroll{\mktab,\mmktab}{\msctx}}
    \quad
    \inferrule{\msctx \in I(\mktab,\mmktab,\mactx) \quad
      \mkont \sqsubseteq \unroll{\mktab,\mmktab}{\msctx}} {\mkont
      \sqsubseteq \unroll{\mktab,\mmktab}{\mactx}}
    \\
    \inferrule{ }
              {\epsilon \sqsubseteq \unrollC{\mktab_{\makont},\mktab_{\mamkont},\mmktab}{\epsilon}}
    \\
    \inferrule{(\makont,\mamkont) \in \mktab_{\mamkont}(\mmctx) \\
               \mkont \sqsubseteq \unroll{\mktab_{\makont},\mmktab}{\makont} \\
               \mmkont \sqsubseteq \unrollC{\mktab_{\makont},\mktab_{\mamkont},\mmktab}{\mamkont}}
              {\mkapp{\mkont}{\mmkont} \sqsubseteq \unrollC{\mktab_{\makont},\mktab_{\mamkont},\mmktab}{\mmctx}}
  \end{mathpar}
  
  \caption{Order on (meta-)continuations}
\label{fig:cont-order}
\end{figure}
\begin{theorem}[Soundness]
  If $\somestate \stepto_{\SRSt} \nextstate$, and $\somestate \sqsubseteq \someotherstate$ then there is $\nextotherstate$ such that $\someotherstate \stepto_{\SRSChKKt} \nextotherstate$ and
$\nextstate \sqsubseteq \nextotherstate$.
\end{theorem}

To substantiate our claim that fresh allocation leads to an exact semantics, we need to show an invariant on our continuation stores: no circular references, all mappings are to singleton sets, and all contexts have unique stores unless all components of the context are the same except for the expression and timestamp.
\begin{mathpar}
  \inferrule{\wf(\mktab_\makont) \\ \wfC(\mktab_\makont,\mktab_\mamkont) \\
\forall \mctx\in\dom(\mktab_\makont). |\mktab_\makont(\mctx)|=1
\\
\forall \mmctx\in\dom(\mktab_\mamkont). |\mktab_\mamkont(\mmctx)|=1 \\
\forall \mctx\neq\mctx'. \compatible{\mctx}{\mctx'} \vee \pi_2(\mctx) \neq \pi_2(\mctx') \\
\forall \mmctx\neq\mmctx'. \compatible{\mmctx}{\mmctx'} \vee \pi_2(\mmctx) \neq \pi_2(\mmctx') \\
}{\inv_{\fresh}(\tpl{\mexpr,\menv, \mastore, \mmktab,\makont,\mamkont}, \mktab_{\makont}, \mktab_{\mamkont})}
 \\
\inferrule{ }{\compatible{\tpl{\_,\menv,\mastore,\mmktab}}{\tpl{\_,\menv,\mastore,\mmktab}}}
\end{mathpar}
The $\wf$ and $\wfC$ propositions describe the well-founded order on the continuation stores, assuming the codomains contain only singleton sets.
\begin{mathpar}
  \inferrule{ }{\wf(\bot)} \quad
  \inferrule{\makont \sqsubseteq \mktab_{\makont}|_{\overline{\mctx}}}
            {\wf(\extm{\mktab_{\makont}}{\mctx}{\set{\makont}})} \\
  \inferrule{ }{\wfC(\bot)} \quad \inferrule{(\makont,\mamkont) \sqsubseteq \mktab_{\makont},\mktab_{\mamkont}|_{\overline{\mmctx}}}
                                            {\wfC(\mktab_{\makont},\extm{\mktab_{\mamkont}}{\mmctx}{\set{(\makont,\mamkont)}})} \\
\inferrule{ }{\epsilon \sqsubseteq \mktab_{\makont}} \quad
\inferrule{\mctx \in \dom(\mktab_\makont)}
          {\kcons{\mkframe}{\mctx} \sqsubseteq \mktab_{\makont}} \\
\inferrule{\makont \sqsubseteq \mktab_\makont}
          {(\makont,\epsilon) \sqsubseteq \mktab_\makont,\mktab_{\mamkont}} \quad
\inferrule{\makont \sqsubseteq \mktab_\makont \\
           \mmctx \in \dom(\mktab_\mamkont)}
          {(\makont,\mmctx) \sqsubseteq \mktab_\makont,\mktab_\mamkont}
\end{mathpar}

\begin{lemma}[Freshness invariant]
  If $\alloc$ produces fresh addresses, $\inv_{\fresh}(\mastate,\mktab_\makont,\mktab_\mamkont)$ and
$\mastate,\mktab_{\makont},\mktab_{\mamkont} \stepto
\mastate',\mktab'_{\makont},\mktab'_{\mamkont}$ then
$\inv_{\fresh}(\mastate',\mktab'_{\makont},\mktab'_{\mamkont})$.
\end{lemma}
\begin{theorem}[Complete for fresh allocation]
  If $\alloc$ produces fresh addresses then the resulting semantics is complete with respect to states satisfying the invariant.
\end{theorem}

%  LocalWords:  pushdown storeable codomain AAM ianjohnson Kiselyov
%  LocalWords:  modularly parsers undelimited Biernacki ev al ntinue
%  LocalWords:  Composable dereferences metafunction timestamped
%  LocalWords:  timestamp codomains
